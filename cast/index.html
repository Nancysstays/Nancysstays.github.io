<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Broadcast</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
  <style>
    body {
      font-family: sans-serif;
    }
    #video-container {
      width: 640px;
      height: 480px;
      margin: 0 auto;
      border: 1px solid #ccc;
      overflow: hidden;
    }
    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: rotateY(180deg); 
    }
    #remote-videos {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* Responsive grid */
      gap: 10px;
      margin-top: 20px;
    }
    .remote-video {
      width: 100%;
      height: auto;
      border: 1px solid #ccc;
    }
    .controls {
      margin-top: 20px;
      text-align: center;
    }
    #status {
      margin-top: 10px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="mt-5 text-center">WebRTC Broadcast</h1>

    <div id="video-container" class="mt-4">
      <video id="video" autoplay playsinline muted></video>
    </div>

    <div class="controls">
      <button id="start-broadcast" class="btn btn-primary">Start Broadcast</button>
      <button id="stop-broadcast" class="btn btn-secondary" disabled>Stop Broadcast</button>
      <div id="status"></div>
    </div>

    <div class="viewers mt-4">
      <h2>Viewers:</h2>
      <div id="remote-videos"></div>
    </div>
  </div>

  <script>
    const apiKey = 'YOUR_API_KEY'; // Replace with your actual API key
    const signalingServerUrl = 'wss://your-signaling-server.com'; // Replace with your signaling server URL

    const video = document.getElementById('video');
    const startBroadcastButton = document.getElementById('start-broadcast');
    const stopBroadcastButton = document.getElementById('stop-broadcast');
    const statusDiv = document.getElementById('status');
    const remoteVideosContainer = document.getElementById('remote-videos');

    let localStream;
    let peerConnections = {}; 

    // --- Signaling ---

    const signalingServer = new WebSocket(signalingServerUrl);

    signalingServer.onopen = () => {
      console.log('Connected to signaling server');
      statusDiv.textContent = "Ready to broadcast."; 
    };

    signalingServer.onmessage = async (event) => {
      const message = JSON.parse(event.data);

      if (message.type === 'viewer-offer') {
        const peerId = message.peerId;
        const offer = message.offer;
        createPeerConnection(peerId, offer);
      } else if (message.type === 'viewer-ice-candidate') {
        const peerId = message.peerId;
        const candidate = message.candidate;
        if (peerConnections[peerId]) {
          await peerConnections[peerId].addIceCandidate(candidate);
        }
      } else if (message.type === 'viewer-left') {
        const peerId = message.peerId;
        removeViewer(peerId);
        delete peerConnections[peerId]; 
      }
    };

    signalingServer.onerror = (error) => {
      console.error('Signaling server error:', error);
      statusDiv.textContent = "Error: Could not connect to signaling server.";
    };

    signalingServer.onclose = () => {
      console.log('Disconnected from signaling server');
      statusDiv.textContent = "Disconnected from signaling server.";
    };

    // --- WebRTC Functions ---

    async function startBroadcast() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        video.srcObject = localStream;

        statusDiv.textContent = "Broadcasting...";
        startBroadcastButton.disabled = true;
        stopBroadcastButton.disabled = false;
      } catch (error) {
        console.error('Error accessing media devices:', error);
        statusDiv.textContent = "Error: Could not access camera/microphone.";
      }
    }

    function stopBroadcast() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        video.srcObject = null;

        // Close all peer connections
        for (const peerId in peerConnections) {
          peerConnections[peerId].close();
        }
        peerConnections = {}; 

        statusDiv.textContent = "Broadcast stopped.";
        startBroadcastButton.disabled = false;
        stopBroadcastButton.disabled = true;
      }
    }

    async function createPeerConnection(peerId, offer) {
      const pc = new RTCPeerConnection();
      peerConnections[peerId] = pc;

      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      signalingServer.send(JSON.stringify({
        type: 'broadcaster-answer',
        peerId: peerId,
        answer: answer
      }));

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          signalingServer.send(JSON.stringify({
            type: 'broadcaster-ice-candidate',
            peerId: peerId,
            candidate: event.candidate
          }));
        }
      };

      pc.ontrack = (event) => {
        // This is for receiving audio/video from viewers (if needed)
      };

      const remoteVideo = document.createElement('video');
      remoteVideo.classList.add('remote-video');
      remoteVideo.autoplay = true;
      remoteVideo.playsinline = true;
      remoteVideo.srcObject = event.streams[0]; 
      remoteVideosContainer.appendChild(remoteVideo);
    }

    function removeViewer(peerId) {
      const videoElement = document.querySelector(`#remote-videos video[data-peer-id="${peerId}"]`);
      if (videoElement) {
        videoElement.remove();
      }
    }

    // --- Event Listeners ---

    startBroadcastButton.addEventListener('click', startBroadcast);
    stopBroadcastButton.addEventListener('click', stopBroadcast);

    // ... (Helper functions like generateUniqueId, getBrowserInfo, etc.) ...
  </script>
</body>
</html>
